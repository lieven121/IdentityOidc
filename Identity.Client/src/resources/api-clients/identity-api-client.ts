//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { useConfigStore } from '@/stores/config'
export class ClientBase {
  //   private alertStore: any;
  private configStore

  public constructor() {
    this.configStore = useConfigStore()
    // this.alertStore = useAlertStore();
  }

  public getBaseUrl(url: string, defaultUrl: string | undefined | null) {
    return this.configStore.transformBaseUrl(this.configStore.config?.apiUrl ?? defaultUrl ?? url)
  }

  protected async transformOptions(options: RequestInit): Promise<RequestInit> {
    // await this.authStore.getAccessToken()
    options.headers = {
      ...options.headers,
      'Content-Type': 'application/json',
    }

    return options
  }

  protected async transformResult(
    url: string,
    response: Response,
    processor: (response: Response) => any,
  ) {
    // clone() throws a TypeError if the response body has already been used.
    // In fact, the main reason clone() exists is to allow multiple uses of body objects(when they are one - use only.)
    // https://developer.mozilla.org/en-US/docs/Web/API/Response/clone
    // if (response.status === 403 || response.status === 401) {
    //   if (window.location.pathname !== '/unauthorized') window.location.href = '/unauthorized'
    // } else
    if (400 <= response.status && response.status < 600 && response.body) {
      let errorText = undefined
      try {
        errorText = ((await response.clone().json()) as any)?.title
      } catch (e: Error | any) {
        console.error(e)
        // If not json then json() will throw an error
      }
      errorText ??= response.clone ? await response.clone().text() : response //   this.alertStore.error(await errorText, 10000);
    }
    return processor(response.clone())
  }
}

export class StatusClient extends ClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://localhost:7038", baseUrl);
    }

    status(): Promise<StatusDto> {
        let url_ = this.baseUrl + "/api/status";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processStatus(_response));
        });
    }

    protected processStatus(response: Response): Promise<StatusDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StatusDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<StatusDto>(null as any);
    }
}

export class UsersClient extends ClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://localhost:7038", baseUrl);
    }

    me(): Promise<UserDto> {
        let url_ = this.baseUrl + "/api/users/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processMe(_response));
        });
    }

    protected processMe(response: Response): Promise<UserDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto>(null as any);
    }
}

export class IdentityClient extends ClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://localhost:7038", baseUrl);
    }

    login(dto: LoginRequest): Promise<void> {
        let url_ = this.baseUrl + "/api/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dto);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processLogin(_response));
        });
    }

    protected processLogin(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    logout(): Promise<void> {
        let url_ = this.baseUrl + "/api/logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processLogout(_response));
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class OpenIdConnectClient extends ClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("https://localhost:7038", baseUrl);
    }

    authorize(): Promise<void> {
        let url_ = this.baseUrl + "/connect/authorize";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processAuthorize(_response));
        });
    }

    protected processAuthorize(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    token(): Promise<void> {
        let url_ = this.baseUrl + "/connect/token";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processToken(_response));
        });
    }

    protected processToken(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    userinfo(): Promise<Claim[]> {
        let url_ = this.baseUrl + "/connect/userinfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUserinfo(_response));
        });
    }

    protected processUserinfo(response: Response): Promise<Claim[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Claim.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Claim[]>(null as any);
    }

    endsession(): Promise<void> {
        let url_ = this.baseUrl + "/connect/endsession";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processEndsession(_response));
        });
    }

    protected processEndsession(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class StatusDto implements IStatusDto {
    api?: string;
    db?: string;
    timeStamp?: Date;

    constructor(data?: IStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.api = _data["api"];
            this.db = _data["db"];
            this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): StatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["api"] = this.api;
        data["db"] = this.db;
        data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>undefined;
        return data;
    }
}

export interface IStatusDto {
    api?: string;
    db?: string;
    timeStamp?: Date;
}

export class UserDto implements IUserDto {
    id?: string;
    userName?: string;
    email?: string;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["email"] = this.email;
        return data;
    }
}

export interface IUserDto {
    id?: string;
    userName?: string;
    email?: string;
}

export class LoginRequest implements ILoginRequest {
    email?: string;
    password?: string;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
            this.twoFactorCode = _data["twoFactorCode"];
            this.twoFactorRecoveryCode = _data["twoFactorRecoveryCode"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        data["twoFactorCode"] = this.twoFactorCode;
        data["twoFactorRecoveryCode"] = this.twoFactorRecoveryCode;
        return data;
    }
}

export interface ILoginRequest {
    email?: string;
    password?: string;
    twoFactorCode?: string | undefined;
    twoFactorRecoveryCode?: string | undefined;
}

export class Claim implements IClaim {
    customSerializationData?: string | undefined;
    issuer?: string;
    originalIssuer?: string;
    properties?: { [key: string]: string; };
    subject?: ClaimsIdentity | undefined;
    type?: string;
    value?: string;
    valueType?: string;

    constructor(data?: IClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customSerializationData = _data["customSerializationData"];
            this.issuer = _data["issuer"];
            this.originalIssuer = _data["originalIssuer"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
            this.subject = _data["subject"] ? ClaimsIdentity.fromJS(_data["subject"]) : <any>undefined;
            this.type = _data["type"];
            this.value = _data["value"];
            this.valueType = _data["valueType"];
        }
    }

    static fromJS(data: any): Claim {
        data = typeof data === 'object' ? data : {};
        let result = new Claim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customSerializationData"] = this.customSerializationData;
        data["issuer"] = this.issuer;
        data["originalIssuer"] = this.originalIssuer;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        data["subject"] = this.subject ? this.subject.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["value"] = this.value;
        data["valueType"] = this.valueType;
        return data;
    }
}

export interface IClaim {
    customSerializationData?: string | undefined;
    issuer?: string;
    originalIssuer?: string;
    properties?: { [key: string]: string; };
    subject?: ClaimsIdentity | undefined;
    type?: string;
    value?: string;
    valueType?: string;
}

export class ClaimsIdentity implements IClaimsIdentity {
    authenticationType?: string | undefined;
    isAuthenticated?: boolean;
    actor?: ClaimsIdentity | undefined;
    bootstrapContext?: any | undefined;
    claims?: Claim[];
    customSerializationData?: string | undefined;
    externalClaims?: Claim[][];
    label?: string | undefined;
    name?: string | undefined;
    nameClaimType?: string;
    roleClaimType?: string;

    constructor(data?: IClaimsIdentity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authenticationType = _data["authenticationType"];
            this.isAuthenticated = _data["isAuthenticated"];
            this.actor = _data["actor"] ? ClaimsIdentity.fromJS(_data["actor"]) : <any>undefined;
            this.bootstrapContext = _data["bootstrapContext"];
            if (Array.isArray(_data["claims"])) {
                this.claims = [] as any;
                for (let item of _data["claims"])
                    this.claims!.push(Claim.fromJS(item));
            }
            this.customSerializationData = _data["customSerializationData"];
            if (Array.isArray(_data["externalClaims"])) {
                this.externalClaims = [] as any;
                for (let item of _data["externalClaims"])
                    this.externalClaims!.push(item);
            }
            this.label = _data["label"];
            this.name = _data["name"];
            this.nameClaimType = _data["nameClaimType"];
            this.roleClaimType = _data["roleClaimType"];
        }
    }

    static fromJS(data: any): ClaimsIdentity {
        data = typeof data === 'object' ? data : {};
        let result = new ClaimsIdentity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authenticationType"] = this.authenticationType;
        data["isAuthenticated"] = this.isAuthenticated;
        data["actor"] = this.actor ? this.actor.toJSON() : <any>undefined;
        data["bootstrapContext"] = this.bootstrapContext;
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["customSerializationData"] = this.customSerializationData;
        if (Array.isArray(this.externalClaims)) {
            data["externalClaims"] = [];
            for (let item of this.externalClaims)
                data["externalClaims"].push(item);
        }
        data["label"] = this.label;
        data["name"] = this.name;
        data["nameClaimType"] = this.nameClaimType;
        data["roleClaimType"] = this.roleClaimType;
        return data;
    }
}

export interface IClaimsIdentity {
    authenticationType?: string | undefined;
    isAuthenticated?: boolean;
    actor?: ClaimsIdentity | undefined;
    bootstrapContext?: any | undefined;
    claims?: Claim[];
    customSerializationData?: string | undefined;
    externalClaims?: Claim[][];
    label?: string | undefined;
    name?: string | undefined;
    nameClaimType?: string;
    roleClaimType?: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

/* eslint-disable @typescript-eslint/no-explicit-any */

/*
// i mport { useAlertStore } from '@/stores/alert';
 !
 ! Recreate api client after modifying this file to see changes
 !
 */